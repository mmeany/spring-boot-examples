# Testing

Much of the testing is standard Spring Boot testing using `SpringBootTest` or `WebMvcTest`, all standard stuff.

Of more interest is the OAuth2 test. For this [TestContainers](https://www.testcontainers.org) have been used,
specifically the [JUnit5 Integration](https://www.testcontainers.org/test_framework_integration/junit_5/) and
[Singleton Pattern](https://www.testcontainers.org/test_framework_integration/manual_lifecycle_control/) to make
sure only one instance of container is spun up in an abstract class, [AbstractTestContainersBase](../rbac-rest-api/src/test/java/net/mmeany/play/quote/controller/AbstractTestContainersBase.java),
and that instance is used for all test classes extending it.

Documentation for the Keycloak test container can be found on [GitHub](https://github.com/dasniko/testcontainers-keycloak).

The abstract class has a few utility methods available for obtaining metadata from the Keycloak instance and for
making generic `http` get and post requests which will prove useful for testing later.

The Keycloak container configuration pulls in a specific container image, imports the `dev` realm and waits for the
server to start serving requests:

```java
public class AbstractTestContainersBase {
    @Container
    static KeycloakContainer keycloak = new KeycloakContainer("quay.io/keycloak/keycloak:19.0.1")
            .withRealmImportFile("/dev-realm.json")
            .waitingFor(Wait.forHttp("/").forStatusCode(200));
}
```

And one of the tests making use of this container and one of the utility methods:

```java

@SpringBootTest
@AutoConfigureMockMvc
@Testcontainers
@ActiveProfiles(profiles = {"test", "test-containers"})
@TestInstance(TestInstance.Lifecycle.PER_CLASS)
class QuoteControllerOAuthTestContainersIT extends AbstractTestContainersBase {

    @Test
    void shouldNotFailAuthWithAdminCredentials() throws Exception {
        String accessToken = getAccessToken(TEST_REALM, TEST_CLIENT_ID, TEST_USER_1_USERNAME, TEST_USER_1_PASSWORD);
        mockMvc.perform(get("/quote")
                        .header(HttpHeaders.AUTHORIZATION, "Bearer " + accessToken)
                )
                .andExpect(status().isOk());
    }
}
```

Should point out here that the Keycloak instance is using an import of the same `dev` schema from which the
public key stored in application.yml was obtained. That is how come JWTs generated by the Keycloak instance
can be decoded by the application.

